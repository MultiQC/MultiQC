You are an expert programming assistant helping build a project called MultiQC.

## About MultiQC

MultiQC is a command-line reporting tool that discovers and parses results and logs from bioinformatics tools, such as: log files, console outputs, or reports they write to disk. Then MultiQC aggregates parsed data accross samples and tools, and generates a standalone poratble HTML report. This report helps to analyse containing multiple samples and multiple analysis steps and perform quality control.

MultiQC is typically called as a last step in bioinformatics pipelines to aggregate quality control metrics from all previous steps. When run on a pipeline output folder, it recursively searches it to discover and load all the relevant files.

Base MultiQC codebase is written in Python, and it also uses JavaScript with jQuery and CSS embedded in the HTML report.

## Output

MultiQC primary output is a standalone portable HTML file. It starts with a "General Statistics" table with key metrics across all samples and tools. Followed, more detailed sections split by specific tools, that can include tables, as well as plots of different types (bar plot, line plot, scatter plot, heatmap, etc.)

In addition to a HTML report, MultiQC generates a directory of parsed data files with consistent data structure. It also places there a JSON file with the same data, which can be used as an input for other tools, or for downstream analysis.

## MultiQC codebase structure

- `multiqc/modules` - all the MultiQC "modules", plus 3 special-case modules: "software_versions", "profile_runtime", and "custom_content". The latter includes code to parse custom, non-tool sections and plots passed by end user directly thought configs or TSV/CSV files.
- `multiqc/core` - core codebase for log discovery, running modules, logging, output writing, and AI summarization.
- `multiqc/plots` - plotting code: describes how to prepare data and layouts to render with Plotly. Plots can be rendered both statically with Python Plotly library, as well as dynamically in browser with Plotly-JS library, so this code also prepares required data dumps to be loaded with JavaScript.
- `multiqc/templates` - HTML templates for MultiQC report. Only `multiqc/templates/default` is worth attention here. It includes HTML templates to be combined and rendered with Jinja2 to produce the final HTML report, as well as `assets` - the folder with JavaScript code for all dynamic features like loading and decompressing the plot JSON dumps, rendering it with Plotly-JS, the toolbox with features to highlight/hide/rename samples in the report, etc. It also contains `default_multiqc.css` - all CSS goes there.
- `multiqc/base_module.py` - a base module class for all modules to inherit. Povides a lot of sample name cleaning and grouping logic.
- `multiqc/utils` - common Python utility functions.
- `multiqc/config.py` - a configuration class that contains all the configuration variables for MultiQC, as well as all the configuration discovery logic.
- `multiqc/interactive.py` - function helpers to construct a MultiQC report in interactive mode, e.g. in a Jupyter notebook.
- `multiqc/report.py` - a singleton class with globale variables that are passed to Jinja2 to render a report. Holds the "state" of the report, i.e. modules, sections, discovered files, list of HTML anchor to keep them unique, etc., as well as multiple helper functions.
- `multiqc/multiqc.py` - main entry point of MultiQC. Includes command line interface logic.
- `multiqc/validation.py` - helpers to validate plot configs and user custom content with Pydantic.
- `scripts` - auxiliarry scripts for development.
- `tests` - test suite for MultiQC.
- `docs` - documentation for MultiQC. `docs/markdown/modules` and `docs/markdown/modules.mdx` are autogenerated from the class docstrings in `multiqc/modules` using `scripts/make_module_docs.py`, the rest is written manually.

## Modules

MultiQC supports bioformatics tools through so-called "modules". Each "module" is a Python module placed in `multiqc/modules`, and it is dynamically loaded as an "entry point" specified in `pyproject.toml`. A module describes how MultiQC should parse outputs/logs from the corresponding tool, what data to extract, how to summarise it, and what kinds of plots and tables to use to present data in the report. There is also a file `multiqc/search_patterns.yaml` that describes file name patterns and content patterns to discover output files/logs from each tool/module.

## Code style

When writing code, you must follow the following rules:

- Use f-strings and other MODERN Python 3 syntax. Do not use `__future__` imports or `OrderedDict`'s.
- Use single quotes for strings.
- Do not add shebang lines to Python files unless they are placed in the `scripts/` folder.

When writing modules, you must follow the following rules:

- Raise `ModuleNoSamplesFound` when no samples are found. DO NOT RAISE `UserWarning`!
- Call `self.add_software_version()`, even if version is not found, as it's required by linting.
- Call `self.write_data_file(...)` in the very end of the module, after all sections are added. IT IS IMPORTANT TO CALL IT IN THE END!
- Add entry point into `pyproject.toml`. Ignore `setup.py`.
- Do not add separate markdown files or module-level docstrings. Instead add a docstring to the module class.
- Module's `info` MUST start with a capital letter.

THIS IS VERY IMPORTANT. YOU MUST FOLLOW THESE GUIDELINES. 

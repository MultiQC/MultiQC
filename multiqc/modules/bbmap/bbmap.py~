#!/usr/bin/env python

""" MultiQC module to parse output from BBMap """

file_types = {
    'aqhist': {
        'descr': 'Histogram of average read quality.',
        'cols': [
            'Quality',
            'count1',
            'fraction1',
            'count2',
            'fraction2'
        ]
    },
#basecov
#  - Coverage per base location.
#  - too big to interpret here
    'bhist' : {
        'descr': 'Base composition histogram by position.',
        'cols': [
            'Pos', 'A', 'C', 'G', 'T', 'N'
        ]
    },
    'bincov': {
        'descr': 'Binned coverage per location (one line per X bases).',
        'kvrows': ['Mean', 'STDev' ],
        'cols': [
            'RefName',
            'Cov',
            'Pos',
            'RunningPos'
        ]
    },
    'bqhist': {
        'descr': 'Quality histogram designed for box plots.',
        'cols': [
            'BaseNum',
            'count_1', 'min_1', 'max_1', 'mean_1', 'Q1_1', 'med_1', 'Q3_1', 'LW_1', 'RW_1',
            'count_2', 'min_2', 'max_2', 'mean_2', 'Q1_2', 'med_2', 'Q3_2', 'LW_2', 'RW_2'
        ]
    }
    'covhist': {
        'descr': 'Histogram of # occurrences of each depth level.',
        'cols': ['Coverage', 'numBases']
    }
    'covstats': {
        'descr': 'Per-scaffold coverage info.'
        'cols': [
            'ID',
            'Avg_fold',
            'Length',
            'Ref_GC',
            'Covered_percent',
            'Covered_bases',
            'Plus_reads',
            'Minus_reads',
            'Median_fold',
            'Read_GC',
            'Std_Dev'
        ]
    },
    'ehist': {
        'descr': 'Errors-per-read histogram.',
        'cols': ['Errors', 'Count' ]
    },
    'gchist' : {
        'descr': 'Read GC content histogram.',
        'kvrows': ['Mean', 'Median', 'Mode', 'STDev'],
        'cols': ['GC', 'Count' ]
    }
    'idhist': {
        'descr': 'Histogram of read count versus percent identity.',
        'kvrows': ['Mean_reads', 'Mean_bases',
                   'Median_reads', 'Median_bases',
                   'Mode_reads', 'Mode_bases',
                   'STDev_reads', 'STDev_bases' ],
        'cols': ['Identity', 'Reads', 'Bases' ]
    },
    'ihist': {
        'descr': 'Histogram of insert sizes (for paired reads).',
        'kvrows': ['Mean', 'Median', 'STDev', 'PercentOfPairs'],
        'cols': ['InsertSize', 'Count' ]
    },
    'indelhist': {
        'descr': 'Indel length histogram.',
        'cols': ['Length', 'Deletions', 'Insertions']
    }
    'lhist' : {
        'descr': 'Read length histogram.',
        'cols': ['Length', 'Count' ]
    },
    'mhist': {
        'descr': 'Histogram of match, sub, del, and ins rates by read location.',
        'cols': [
            'BaseNum',
            'Match1', 'Sub1', 'Del1', 'Ins1', 'N1', 'Other1',
            'Match2', 'Sub2', 'Del2', 'Ins2', 'N2', 'Other2'
        ]
    },
    'qahist': {
        'descr': 'Quality accuracy histogram of error rates versus quality score.'
        'kvrows': ['Deviation', 'DeviationSub' ],
        'cols': [
            'Quality', 'Match', 'Sub', 'Ins', 'Del', 'TrueQuality', 'TrueQualitySub'
        ]
    },
    'qhist': {
        'descr': 'Quality histogram by position.',
        'cols': [
            'BaseNum',
            'Read1_linear', 'Read1_log', 'Read1_measured',
            'Read2_linear', 'Read2_log', 'Read2_measured'
        ]
    },
    'rpkm': {
        'descr': 'Per-scaffold RPKM/FPKM counts.',
        'kvrows': ['File', 'Reads', 'Mapped', 'RefSequences' ],
        'cols': [
            'Name', 'Length', 'Bases', 'Coverage', 'Reads', 'RPKM', 'Frags', 'FPKM'
        ]
    }
}

statsfile_machine_keys = [
    'Reads_Used', 'Bases_Used', 'Reads/sec', 'kBases/sec',
    
    'R1_Mapped_Percent', 'R1_Unambiguous_Percent', 'R1_Mapped_Reads',
    'R1_Unambiguous_Reads', 'Mated_Pairs', 'Bad_Pairs', 'R1_Rescued',
    'Avg_Insert_Size', 'R1_Perfect_Best_Site', 'R1_Semiperfect_Site',
    'R1_Ambiguous_Mapping', 'R1_Low_Quality_Discards', 'R1_Match_Rate',
    'R1_Error_Rate', 'R1_Sub_Rate', 'R1_Del_Rate', 'R1_Ins_Rate',
    'R1_N_Rate', 'R1_Match_Count', 'R1_Error_Count', 'R1_Sub_Count',
    'R1_Del_Count', 'R1_Ins_Count', 'R1_N_Count',

    'R2_Mapped_Percent', 'R2_Unambiguous_Percent', 'R2_Mapped_Reads',
    'R2_Unambiguous_Reads', 'R2_Rescued', 'R2_Perfect_Best_Site',
    'R2_Semiperfect_Site', 'R2_Ambiguous_Mapping', 'R2_Low_Quality_Discards',
    'R2_Match_Rate', 'R2_Error_Rate', 'R2_Sub_Rate', 'R2_Del_Rate',
    'R2_Ins_Rate', 'R2_N_Rate', 'R2_Match_Count', 'R2_Error_Count',
    'R2_Sub_Count', 'R2_Del_Count', 'R2_Ins_Count', 'R2_N_Count',
    'R2_Mapped_Percent',
]

from __future__ import print_function
import logging
import re

from multiqc import config
from multiqc.plots import bargraph
from multiqc.modules.base_module import BaseMultiqcModule

# Initialize the logger
log = logging.getLogger(__name__)

class MultiqcModule(BaseMultiqcModule):
    """ BBMap module, tries to identify and parse tons of output files
    generated by BBMap
    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="BBTools",
            anchor="bbmap",
            href="http://jgi.doe.gov/data-and-tools/bbtools/"
            infp="is a suite of fast, multithreaded bioinformatics tools designed for analysis of DNA and RNA sequence data."
        )

        # Find output files

        for f in self.find_log_files(config.sp('bbmap'], filehandles=True):
            repr(f)
            
            
                                            

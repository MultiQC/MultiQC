import logging
import re

from multiqc.base_module import BaseMultiqcModule
from multiqc.plots import table
from multiqc.plots.table_object import TableConfig

log = logging.getLogger(__name__)


class MultiqcModule(BaseMultiqcModule):
    """The module parses the output files generated by CheckM.
    It will only parse an output file from `checkm lineage_wf`, `checkm taxonomy_wf`, and `checkm qa`.
    The output file needs to be in format 1 (`-o 1`).
    All statistics for all samples are saved to `multiqc_data/checkm-table.txt`.

    This has been tested with CheckM v1.2.1 .
    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="CheckM",
            anchor="checkm",
            href="https://github.com/Ecogenomics/CheckM",
            info="CheckM estimates genome completeness and contamination based on the presence or absence of marker genes.",
            doi=["10.1101/gr.186072.114"],
        )

        self.checkm_data = {}
        for f in self.find_log_files(
            "checkm",
            filehandles=True,
        ):
            self.parse_file(f)
            self.add_data_source(f)
        self.checkm_data = self.ignore_samples(self.checkm_data)
        if len(self.checkm_data) == 0:
            raise ModuleNoSamplesFound
        log.info(f"Found {len(self.checkm_data)} reports")
        self.add_software_version()

        self.mag_quality_table()

    def parse_file(self, f):
        """Parses the file from `checkm qa`.
        Outputs from this command can come in several formats and with spaces or tabs.
        This is tested with formats 1 and 2 `-o [1|2]`, and with spaces (default) and tabs `--tab-file`
        """

        column_names_format_1 = (
            "Bin Id",
            "Marker lineage",
            "# genomes",
            "# markers",
            "# marker sets",
            "0",
            "1",
            "2",
            "3",
            "4",
            "5+",
            "Completeness",
            "Contamination",
            "Strain heterogeneity",
        )
        column_names_format_2 = (
            "Bin Id",
            "Marker lineage",
            "# genomes",
            "# markers",
            "# marker sets",
            "Completeness",
            "Contamination",
            "Strain heterogeneity",
            "Genome size (bp)",
            "# ambiguous bases",
            "# scaffolds",
            "# contigs",
            "N50 (scaffolds)",
            "N50 (contigs)",
            "Mean scaffold length (bp)",
            "Mean contig length (bp)",
            "Longest scaffold (bp)",
            "Longest contig (bp)",
            "GC",
            "GC std (scaffolds > 1kbp)",
            "Coding density",
            "Translation table",
            "# predicted genes",
            "0",
            "1",
            "2",
            "3",
            "4",
            "5+",
        )
        parsed_data = {}
        for line in f["f"]:
            if line.startswith("--"):
                continue
            elif line.startswith(("  Bin Id ", "Bin Id\t")):
                # we need to check which format the data is in so we can grab the correct columns later
                format_different_column = re.split(r"\t| {3,}", line.rstrip())[5]
                if format_different_column == "0":
                    column_names = column_names_format_1
                elif format_different_column == "Completeness":
                    column_names = column_names_format_2
                else:
                    raise ValueError
                continue
            column_values = re.split(r"\t| {3,}", line.rstrip())
            column_values = [None if x == "None" else x for x in column_values]
            parsed_data[column_values[0]] = {k: v for k, v in zip(column_names, column_values) if v}
        self.checkm_data.update(parsed_data)

    def mag_quality_table(self):
        headers = {
            "Marker lineage": {
                "title": "Marker lineage",
                "description": "indicates lineage used for inferring marker set (a precise indication of where a bin was placed in CheckM's reference tree can be obtained with the tree_qa command)",
            },
            "# genomes": {
                "title": "# of genomes",
                "description": "Number of reference genomes used to infer marker set.",
                "min": 0,
            },
            "# markers": {
                "title": "# of markers",
                "description": "Number of inferred marker genes.",
                "min": 0,
                "scale": "YlGn",
            },
            "# marker sets": {
                "title": "# of marker sets",
                "description": "Number of inferred co-located marker sets",
                "min": 0,
                "scale": "YlOrRd-rev",
            },
            "Completeness": {
                "title": "Completeness",
                "description": "Estimated completeness of genome as determined from the presence/absence of marker genes and the expected collocalization of these genes",
                "min": 0,
                "max": 100,
                "suffix": "%",
                "scale": "Purples",
                "format":"{:,.2f}",
            },
            "Contamination": {
                "title": "Contamination",
                "description": "Estimated contamination of genome as determined by the presence of multi-copy marker genes and the expected collocalization of these genes",
                "min": 0,
                "max": 100,
                "suffix":  "%",
                "scale": "Reds",
                "format":"{:,.2f}",
            },
        }
        pconfig = TableConfig(
            title="Genome Quality",
            id="checkm-first-table",
        )
        self.add_section(
            name="Bin quality",
            anchor="checkm-quality",
            description="The quality of microbial genomes recovered from isolates, single cells, and metagenomes.",
            helptext="An automated method for assessing the quality of a genome using a broader set of marker genes specific to the position of a genome within a reference genome tree and information about the collocation of these genes.",
            plot=table.plot(data=self.checkm_data, headers=headers, pconfig=pconfig),
        )
import logging
from typing import Dict, Any

import yaml

from multiqc.base_module import BaseMultiqcModule, ModuleNoSamplesFound
from multiqc.plots import linegraph
from multiqc.plots.linegraph import LinePlotConfig

log = logging.getLogger(__name__)


class MultiqcModule(BaseMultiqcModule):
    """
    Methurator is a Python package designed to estimate sequencing saturation for
    reduced-representation bisulfite sequencing (RRBS) data.

    The module parses the `methurator_summary.yml` file generated by the `methurator downsample`
    command. This file contains:

    - **Reads summary**: Read counts at each downsampling percentage
    - **CpGs summary**: CpG site counts at different coverage thresholds
    - **Saturation analysis**: Model fit results including asymptote and saturation estimates

    The module displays key metrics in the General Statistics table and creates saturation
    curve plots showing how CpG detection changes with sequencing depth.
    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="Methurator",
            anchor="methurator",
            href="https://github.com/VIBTOBIlab/methurator",
            info="Estimates sequencing saturation for reduced-representation bisulfite sequencing (RRBS) data.",
            # doi="",  # No DOI available
        )

        # Store parsed data
        self.methurator_data: Dict[str, Dict[str, Any]] = {}

        # Find and parse methurator summary files
        for f in self.find_log_files("methurator"):
            try:
                parsed = yaml.load(f["f"], Loader=yaml.SafeLoader)
            except Exception as e:
                log.warning(f"Could not parse methurator YAML file '{f['fn']}': {e}")
                continue

            # Extract sample data from the parsed YAML
            samples_data = self._extract_sample_data(parsed)
            if not samples_data:
                log.warning(f"No sample data found in {f['fn']}")
                continue

            for sample_name, sample_data in samples_data.items():
                s_name = self.clean_s_name(sample_name, f)
                if s_name in self.methurator_data:
                    log.debug(f"Duplicate sample name found! Overwriting: {s_name}")
                self.methurator_data[s_name] = sample_data
                self.add_data_source(f, s_name=s_name)

                # Add software version if available
                version = parsed.get("methurator_summary", {}).get("metadata", {}).get("methurator_version")
                self.add_software_version(version, s_name)

        # Filter ignored samples
        self.methurator_data = self.ignore_samples(self.methurator_data)

        # Raise exception if no data found
        if not self.methurator_data:
            raise ModuleNoSamplesFound

        log.info(f"Found {len(self.methurator_data)} samples")

        # Add general stats
        self._add_general_stats()

        # Add saturation curve plot
        self._add_saturation_plot()

        # Write data file (must be last)
        self.write_data_file(self.methurator_data, "methurator")

    def _extract_sample_data(self, parsed: Dict) -> Dict[str, Dict[str, Any]]:
        """Extract per-sample data from the parsed YAML structure."""
        samples_data: Dict[str, Dict[str, Any]] = {}

        summary = parsed.get("methurator_summary", {})
        reads_summary = summary.get("reads_summary", [])
        cpgs_summary = summary.get("cpgs_summary", [])
        saturation_analysis = summary.get("saturation_analysis", [])

        # Build a mapping of sample names to their data
        # The structure is: [{sample_name: [[pct, value], ...]}, ...]

        # Parse reads summary
        reads_by_sample: Dict[str, list] = {}
        for item in reads_summary:
            if isinstance(item, dict):
                for sample_name, data in item.items():
                    reads_by_sample[sample_name] = data

        # Parse CpGs summary
        cpgs_by_sample: Dict[str, Dict[int, list]] = {}
        for item in cpgs_summary:
            if isinstance(item, dict):
                for sample_name, coverage_data in item.items():
                    cpgs_by_sample[sample_name] = {}
                    if isinstance(coverage_data, list):
                        for cov_entry in coverage_data:
                            if isinstance(cov_entry, dict):
                                min_cov = cov_entry.get("minimum_coverage")
                                data = cov_entry.get("data", [])
                                if min_cov is not None:
                                    cpgs_by_sample[sample_name][min_cov] = data

        # Parse saturation analysis
        saturation_by_sample: Dict[str, Dict[int, Dict[str, Any]]] = {}
        for item in saturation_analysis:
            if isinstance(item, dict):
                for sample_name, sat_data in item.items():
                    saturation_by_sample[sample_name] = {}
                    if isinstance(sat_data, list):
                        for sat_entry in sat_data:
                            if isinstance(sat_entry, dict):
                                min_cov = sat_entry.get("minimum_coverage")
                                if min_cov is not None:
                                    saturation_by_sample[sample_name][min_cov] = sat_entry

        # Combine all data for each sample
        all_samples = set(reads_by_sample.keys()) | set(cpgs_by_sample.keys()) | set(saturation_by_sample.keys())

        for sample_name in all_samples:
            sample_data: Dict[str, Any] = {
                "reads": reads_by_sample.get(sample_name, []),
                "cpgs": cpgs_by_sample.get(sample_name, {}),
                "saturation_analysis": saturation_by_sample.get(sample_name, {}),
            }

            # Extract key metrics for general stats (use minimum_coverage=1 as default)
            # Get total reads at 100% (pct=1.0)
            for pct, reads in sample_data["reads"]:
                if pct == 1.0:
                    sample_data["total_reads"] = reads
                    break

            # Get CpGs and saturation metrics for the lowest minimum coverage
            if sample_data["cpgs"]:
                min_coverage = min(sample_data["cpgs"].keys())
                sample_data["min_coverage_used"] = min_coverage

                # Get total CpGs at 100%
                for pct, cpgs in sample_data["cpgs"].get(min_coverage, []):
                    if pct == 1.0:
                        sample_data["total_cpgs"] = cpgs
                        break

                # Get saturation metrics
                sat_data = sample_data["saturation_analysis"].get(min_coverage, {})
                if sat_data.get("fit_success"):
                    sample_data["asymptote"] = sat_data.get("asymptote")
                    sample_data["saturation_pct"] = sat_data.get("saturation")
                    sample_data["fit_success"] = True
                else:
                    sample_data["fit_success"] = False
                    sample_data["fit_error"] = sat_data.get("fit_error")

            samples_data[sample_name] = sample_data

        return samples_data

    def _add_general_stats(self):
        """Add columns to the general statistics table."""
        general_stats_data: Dict[str, Dict[str, Any]] = {}

        for s_name, data in self.methurator_data.items():
            general_stats_data[s_name] = {
                "total_reads": data.get("total_reads"),
                "total_cpgs": data.get("total_cpgs"),
                "asymptote": data.get("asymptote"),
                "saturation_pct": data.get("saturation_pct"),
            }

        headers = {
            "saturation_pct": {
                "title": "Saturation",
                "description": "CpG sequencing saturation (percentage of theoretical maximum CpGs detected)",
                "suffix": "%",
                "max": 100,
                "min": 0,
                "scale": "RdYlGn",
            },
            "asymptote": {
                "title": "Asymptote",
                "description": "Theoretical maximum number of CpG sites (model estimate)",
                "format": "{:,.0f}",
                "scale": "BuPu",
            },
            "total_cpgs": {
                "title": "CpGs",
                "description": "Total number of CpG sites detected at full sequencing depth",
                "format": "{:,.0f}",
                "scale": "Greens",
            },
            "total_reads": {
                "title": "Reads",
                "description": "Total number of reads in the BAM file",
                "format": "{:,.0f}",
                "scale": "Blues",
                "hidden": True,
            },
        }

        self.general_stats_addcols(general_stats_data, headers)

    def _add_saturation_plot(self):
        """Add the CpG saturation curve plot showing CpGs vs reads."""
        # Collect plot data for each sample
        # We'll create one dataset per minimum coverage level found
        plot_data_by_coverage: Dict[int, Dict[str, Dict[float, float]]] = {}

        for s_name, data in self.methurator_data.items():
            # Get total reads at 100% to calculate extrapolated read counts
            total_reads = data.get("total_reads", 0)

            # Use saturation_analysis data which includes projected/extrapolated points
            saturation_analysis = data.get("saturation_analysis", {})
            for min_cov, sat_data in saturation_analysis.items():
                if min_cov not in plot_data_by_coverage:
                    plot_data_by_coverage[min_cov] = {}

                # Extract data points from saturation analysis
                # Structure: [downsampling_pct, cpgs, saturation_pct, is_extrapolated]
                sat_points = sat_data.get("data", [])
                sample_curve: Dict[float, float] = {}
                for point in sat_points:
                    if len(point) >= 2:
                        pct = point[0]
                        cpgs = point[1]
                        # Calculate reads based on downsampling percentage
                        # At pct=1.0 we have total_reads, so reads = total_reads * pct
                        reads = total_reads * pct
                        if reads > 0 or pct == 0:  # Include origin point
                            sample_curve[float(reads)] = float(cpgs)

                if sample_curve:
                    plot_data_by_coverage[min_cov][s_name] = sample_curve

        # Create plot(s) - one per minimum coverage level
        if not plot_data_by_coverage:
            return

        # Sort coverage levels
        coverage_levels = sorted(plot_data_by_coverage.keys())

        # Create data labels for multiple datasets
        if len(coverage_levels) == 1:
            min_cov = coverage_levels[0]
            plot_data = plot_data_by_coverage[min_cov]

            pconfig = LinePlotConfig(
                id="methurator_saturation_plot",
                title="Methurator: CpG Saturation Curve",
                xlab="Number of Reads",
                ylab="Number of CpGs",
                xmin=0,
                ymin=0,
                tt_label="<b>{point.x:,.0f}</b> reads: {point.y:,.0f} CpGs",
            )

            self.add_section(
                name="CpG Saturation Curve",
                anchor="methurator_saturation",
                description=f"Saturation curves showing the number of CpG sites detected at each "
                f"sequencing depth (minimum coverage: {min_cov}x). A flattening curve indicates "
                f"saturation, where additional sequencing yields diminishing returns.",
                plot=linegraph.plot(plot_data, pconfig),
            )
        else:
            # Multiple coverage levels - create switchable datasets
            datasets = []
            data_labels = []

            for min_cov in coverage_levels:
                datasets.append(plot_data_by_coverage[min_cov])
                data_labels.append(
                    {
                        "name": f"Min Coverage {min_cov}x",
                        "ylab": "Number of CpGs",
                        "xlab": "Number of Reads",
                    }
                )

            pconfig = LinePlotConfig(
                id="methurator_saturation_plot",
                title="Methurator: CpG Saturation Curve",
                xlab="Number of Reads",
                ylab="Number of CpGs",
                xmin=0,
                ymin=0,
                tt_label="<b>{point.x:,.0f}</b> reads: {point.y:,.0f} CpGs",
                data_labels=data_labels,
            )

            self.add_section(
                name="CpG Saturation Curve",
                anchor="methurator_saturation",
                description="Saturation curves showing the number of CpG sites detected at each "
                "sequencing depth. Use the buttons to switch between different minimum coverage "
                "thresholds. A flattening curve indicates saturation, where additional sequencing "
                "yields diminishing returns.",
                plot=linegraph.plot(datasets, pconfig),
            )
